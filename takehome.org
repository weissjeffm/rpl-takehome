# -*- mode: org; -*-
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
#+HTML_HEAD: <style> pre.src { background: black; color: white; } #content { max-width: 1000px } </style>
#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="styles.css"/>

#+TITLE: Take Home
#+AUTHOR: Jeff Weiss
#+BABEL: :cache yes
#+OPTIONS: toc:4 h:4
#+STARTUP: showeverything

* Clojure interpreter for stack-based DSL
** Problem statement
*** Explanation of functionality
+ Variables are symbols prefixed with "!", e.g. !v
+ A stack function is defined with "defstackfn". The first argument is the input declaration
  which also provides variable names to the arguments. The stack always starts empty.
+ The implementation of a stackfn is a sequence of stack operations.
+ Using a constant as a stack operation pushes that value onto the stack
+ Using a variable as a stack operation pushes the value for that variable onto the stack.
+ A variable is assigned the top value of the stack by appending =+= to the variable name,
  e.g. =!v+=
+ A function is invoked with =invoke>=. =invoke>= takes as input the operation and the
  arity to use.
+ =<pop>= is a special operation which removes the top value of the stack.
+ =if>= tests if the top value of the stack is truthy to determine which branch to follow. The
  branches are separated with =else>=
*** Notes about your implementation
+ =defstackfn= should be a macro that produces a function invokable like any other
  function.
+ Should provide an informative error if there's an invalid stack operation or a variable is
  referenced that doesn't exist.
+ The example below contains all functionality you need to implement.
+ It should be possible to shadow vars (naming a new local the name of an existing
  variable).
*** Example invocation
#+begin_src clojure
(defstackfn f
  [!a !b !c] ; example uses input: 1 2 4. Stack starts empty.
  !a ; 1
  !b ; 1 2
  (invoke> + 2) ; 3
  !v1+ ; 3
  !c ; 3 4
  !c ; 3 4 4
  <pop> ; 3 4
  2 ; 3 4 2
  (invoke> * 2) ; 3 8
  !v2+ ; 3 8
  (invoke> = 2) ; false
  (if> ; stack empty
    !v1
    !v2
    (invoke> - 2)
    else>
    "false!!" ;; "false!!"
    (invoke> println 1) ; nil
    <pop> ; stack empty
    !v1 ; 3
    !v2 ; 3 8
    (invoke> * 2) ; 24
    )
  )
;; (f 1 2 4) prints "false!!" and returns 24
#+end_src
** Design
*** Basic approach
We'll compile the various statements into forms. Each successive form
will have the state threaded through it with the =->= macro, and its
result will be a new state. We'll wrap a function definition around
that.
*** Variable shadowing
For now there is no variable scoping, and therefore setting a variable
twice will result in clobbering the previous value. Adding scoping
within an =if>= block would be pretty trivial, as the compiled form
still has access to the original variable values, and could return
those as part of the resulting state instead of whatever was created
in the =if>= block. As to which is the better design, it's hard to say
given the extreme simplicity of the language. Scoping is not strictly
needed - the stack provides a similar ability to shadow values (by
placing a new value on ToS and later popping it off).
** Implementation
*** Project file
#+begin_src clojure :tangle project.clj
(defproject redplanetlabs "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "EPL-2.0 OR GPL-2.0-or-later WITH Classpath-exception-2.0"
            :url "https://www.eclipse.org/legal/epl-2.0/"}
  :dependencies [[org.clojure/clojure "1.10.0"]]
  :repl-options {:init-ns redplanetlabs.core})
#+end_src
*** Data structures
Our interpreter will need to keep track of two things:
+ the stack
+ variables

The stack is easily implemented as a clojure list, and the variables
can be a map with symbol keys. The symbols will be the names of the
variables (with decorations =!= and =+= stripped).

#+begin_src clojure :tangle src/redplanetlabs/core.clj :results none
(ns redplanetlabs.core)

(defrecord State [stack vars])

(defn new-state []
  (State. (list) {}))
#+end_src

*** Compiler functions and runtime functions
There are functions that create clojure code from =defstackfn= items
and functions that do the work at runtime. The runtime functions are
sometimes trivial but make compiled code more readable. 
#+begin_src clojure :tangle src/redplanetlabs/core.clj :results none
(defn parse-var-reference
  "Returns a pair or nil. In the pair, the first item is a symbol for
   the variable being referred to (either a get '!v' or set '!v+'
   operation). The second item is a boolean, true for a 'set'
   operation and false for a 'get' operation. Returns nil if it's not
   a proper reference.

   eg !v => [v false], !v+ => [v true], v => nil"
  [sym]
  (let [[_ var set?] (re-find #"^!([^+]+)(\+?)$" (name sym))
        set? (boolean (seq set?))]
    (and var [(symbol var) set?])))

(defn push
  "Push val onto the stack, return the state"
  [state val]
  (update state :stack conj val))

(defn compile-constant
  "Pushes the constant onto the stack"
  [constant]
  `(push ~constant))

(defn throw-error
  "Throws an exception with the format args applied to the given
   format-string as the message"
  [fmt-str & fmt-args]
  (throw (Exception. (apply format fmt-str fmt-args))))

(defn var-lookup
  "Returns the value of a variable or throws exception if it doesn't
  exist"
  [state v]
  (-> state
      :vars
      (get v)
      (or (throw-error "Variable does not exist: %s" (name v)))))

(defn set-var
  "Sets the variable var with the value currently on top of
  stack (tos). Does not change the stack."
  [{:keys [stack] :as state} var]
  (if-let [tos (first stack)]
    (update state :vars assoc var tos)
    (throw-error "Stack underflow setting variable: %s" (name var))))

(defn get-var
  "Gets the variable var and pushes it onto the stack."
  [{:keys [vars] :as state} var]
  (->> var
       (var-lookup state)
       (update state :stack conj)))

(defn pop
  [{:keys [stack] :as state}]
  (if (seq stack)
    (update state :stack rest)
    (throw-error "Stack underflow")))

(defn compile-symbol
  "Emits code that handles symbols (variable get/set, pop)"
  [sym]
  (if (= sym '<pop>)
    `(pop)
    (if-let [var (parse-var-reference sym)]
      (let [[var set?] var]
        `(~(if set? `set-var `get-var) (quote ~var)))
      (throw-error "Unknown variable or symbol: %s" (name sym)))))

(defn invoke
  "Calls f with args taken from the top of the stack. Arity sets the
  number of args to take from the stack. Throws an exception if there
  aren't enough args on the stack."
  [{:keys [stack] :as state} f arity]
  (let [[args stack] (split-at arity stack)]
    (when (not= (count args) arity)
      (throw-error "Stack underflow calling %s" f))
    (->> args
         reverse ;; make the ToS the last argument to the function, so
         ;; that we can write '3 2 -' and get 1 instead of -1
         (apply f)
         (conj stack)
         (assoc state :stack))))

(defn compile-invoke
  "Emits code for invoke>"
  [[f arity]]
  (when (or (not (integer? arity)) (neg? arity))
    (throw-error "Invalid arity: %s" arity))
  (when-not (symbol? f)
    (throw-error "Invalid invocation, function must be a symbol"
                 (str f)))
  `(invoke ~f ~arity))

(defmacro threaded-if
  "Expands from an expression that fits into the threading macro ->
   (in other words, takes the state as the first arg), to a let/if
   that returns the new state"
  [state if-clause else-clause]
  `(let [tos# (-> ~state :stack first)
         newstate# (update ~state :stack rest)]
     (if tos#
       (-> newstate# ~@if-clause)
       (-> newstate# ~@else-clause))))

(declare compile-item)

(defn compile-if
  "Emits code for if> else>"
  [items]
  (let [[if-clause [_ & else-clause]] (split-with #(not= % 'else>) items)
        compiled-if (map compile-item if-clause)
        compiled-else (map compile-item else-clause)]
    `(threaded-if ~compiled-if ~compiled-else)))

(defn compile-list
  "Emits code for a list item (if or invoke)"
  [[function & args]]
  (case function
    if> (compile-if args)
    invoke> (compile-invoke args)
    (throw-error "Unknown function: %s" function)))

(defn compile-item
  "Returns a code snippet that executes the given item inside a
  defstackfn. the form is always one that fits into the -> macro. In
  other words, the first argument to whatever function is called is
  left out. It will be filled in inside the -> macro with a form that
  returns the state that this item needs."
  [item]
  (cond
    (list? item) (compile-list item)
    (symbol? item) (compile-symbol item)
    true (compile-constant item)))

(defn assign-initial-vars
  "Assigns a value to the initial variables specified in the first
  argument to defstackfn. If there are more variables specified than
  arguments, throw an error. If there are more arguments than
  variables, discard the extra arguments."
  [state vars values]
  (when (> (count vars) (count values))
    (throw-error "Not enought arguments to assign all variables"))
  (let [;; discard the leading ! from var names
        vars (map (comp first parse-var-reference) vars)
        ;; match up var names to args (discarding anything leftover)
        kvs (map vector vars values)]
    (update state :vars merge (into {} kvs))))

(defmacro defstackfn
  "Compile a function with the name name-sym, and a list of variable
  names to assign at runtime to the arguments passed to the
  function. The function accepts a variable number of args."
  [name-sym initial-vars & program]
  `(defn ~name-sym [& args#]
     (-> (new-state)
         (assign-initial-vars (quote ~initial-vars) args#)
         ~@(for [item program]
             (compile-item item))
         :stack)))
#+end_src

*** Tests
#+begin_src clojure :tangle test/redplanetlabs/core_test.clj :results none
(ns redplanetlabs.core-test
  (:require [clojure.test :refer :all]
            [redplanetlabs.core :as sut]))

(sut/defstackfn example [!a !b !c] ; example uses input: 1 2 4. Stack starts empty.
  !a ; 1
  !b ; 1 2
  (invoke> + 2) ; 3
  !v1+ ; 3
  !c ; 3 4
  !c ; 3 4 4
  <pop> ; 3 4
  2 ; 3 4 2
  (invoke> * 2) ; 3 8
  !v2+ ; 3 8
  (invoke> = 2) ; false
  (if> ; stack empty
      !v1
    !v2
    (invoke> - 2)
    else>
    "false!!" ;; "false!!"
    (invoke> println 1) ; nil
    <pop> ; stack empty
    !v1 ; 3
    !v2 ; 3 8
    (invoke> * 2) ; 24
    )
  )

(sut/defstackfn nested-if [!y]
  !y !y
  (invoke> pos? 1)
  (if> !y
    (invoke> even? 1)
    (if> 3
      (invoke> + 2)
      else>
      11
      (invoke> * 2))
    else> -99))

(sut/defstackfn shadow [!x !y] !x !y !x+ !x)

(deftest example-test
  (is (= (example 1 2 4) '(24))))

(deftest nested-if-test
  (are [y exp] (= (nested-if y) exp)
    4 '(7)
    5 '(55)
    -4  '(-99 -4)))

(deftest shadow-test
  (is (= (shadow 1 2) '(2 2 1))))
#+end_src

